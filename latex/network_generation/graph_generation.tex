%        File: graph_generation.tex
%     Created: Tue Feb 11 11:00 AM 2014 C
% Last Change: Tue Feb 11 11:00 AM 2014 C
%
\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}

\usepackage[]{amsfonts}
\usepackage[]{amsmath}

\usepackage{algpseudocode}
\usepackage{algorithm}

\title{Génération de graphes}
\author{Igor Colin}
\date{\today}

\newcommand{\tq}{\text{, }}
\newcommand{\card}[1]{\mathrm{Card}\left( #1 \right)}

\begin{document}

\section*{Notations à intégrer}

\begin{itemize}
    \item Soit $V$ un ensemble donné et soit $E \subseteq V \times V$, on note
        $G = (V, E)$ le graphe dont les n\oe{}uds sont les éléments de $V$
        et les arrêtes sont les éléments de $E$. $G$ peut être non-orienté et
        alors pour $(x, y) \in V \times V$ on a
        $(x, y) \in E \Leftrightarrow (y, x) \in E$. \'Eventuellement, les
        arrêtes peuvent posséder des poids, auquel cas on a
        $E \subseteq V \times V \times K$ où $K$ est l'ensemble des poids
        possibles.
    \item Pour $V$ fini de cardinal $N$, on notera $\{X_1, \ldots, X_N\}$
        les éléments de $V$ et les désignera indifféremment par leur nom
        ($X_i$) ou leur indice ($i$).
    \item Dans le cas où $G$ est non-orienté, on notera $(d_i)_{1 \leq i \leq N}$
        les degrés du graphe. Autrement dit, pour $1 \leq i \leq N$,
        \[
            d_i =
            \mathrm{Card}\left( \left\{
                X_j \in V \tq (X_i, X_j) \in E
            \right\} \right)
        \]
    \item De nouveau, si $G$ est non-orienté, on note $D^{(1)}$ la distribution
        des degrés du graphe. Ainsi,
        \[
            D^{(1)}: \left\{
                \begin{array}{r c l}
                    \mathbb{N} & \rightarrow & [0, 1] \\
                    k & \mapsto & \frac{\card{\left\{ X_i \tq d_i = k \right\}}}{\card{V}}
                \end{array}
            \right.
        \]
        On notera également $D^{(2)}$ la distribution jointe des degrés du
        graphe :
        \[
            D^{(2)}: \left\{
                \begin{array}{r c l}
                    \mathbb{N} \times \mathbb{N} & \rightarrow & [0, 1] \\
                    (k, l) & \mapsto &
                    \frac{\card{ \left\{ (i, j) \in E \tq (d_i, d_j) = (k, l) \right\}}}{\card{E}}
                \end{array}
            \right.
        \]
    \item Dans le cas où $G$ est orienté, on notera $d^{in}$ et $d^{out}$
        les degrés respectivement entrants et sortants du graphe. Ainsi,
        pour $1 \leq i \leq N$,
        \[
            \left\{
                \begin{array}{r c l}
                    d^{in}_i &=& \card{ \left\{ j \in V \tq (j, i) \in E \right\}} \\
                    d^{out}_i &=& \card{ \left\{ j \in V \tq (i, j) \in E \right\}} \\
                \end{array}
            \right.
        \]
    \item Pour la partie algorithmique, on considérera la fonction
        \texttt{swap} définie dans l'Algorithme~\ref{alg:def_swap}, permettant
        d'intervertir deux arrêtes.
    \begin{algorithm}
        \caption{Définition de la fonction \texttt{swap}}
        \label{alg:def_swap}
        \begin{algorithmic}[1]
            \Function{swap}{$E$, $(x_1, y_1)$, $(x_2, y_2)$}
                \State $F \gets E \backslash (x_1, y_1)$
                \State $F \gets F \backslash (x_2, y_2)$
                \State $F \gets F \cup (x_1, y_2)$
                \State $F \gets F \cup (x_2, y_1)$

                \Return $F$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}
\end{itemize}

\section{Graphes aléatoires}
\label{sec:graphes_aleatoires}

    \subsection{Loi de Poisson}
    \label{sub:loi_de_poisson}
        Cette catégorie de modèle effectue très peu d'hypothèses sur les
        graphes à générer et permet d'atteindre une grande quantité de graphes
        d'une taille donnée. Ces modèles possèdent deux paramètres. Le premier
        paramètre indique le nombre de n\oe{}uds du graphe à générer. Le
        deuxième paramètre porte sur les arrêtes du graphe ; il n'indique pas
        nécessairement le nombre d'arrêtes générées mais indique au moins leur
        probabilité d'occurence.

        \subsubsection{Modèle de Gilbert}
            Pour $n \in \mathbb{N}^*$ et $0 < p < 1$, le modèle de Gilbert,
            génère un graphe composé de $n$ n\oe{}uds dont chaque arrête
            potentielle a une probabilité $p$ d'être présente, indépendamment
            des autres arrêtes.
            En général, on choisit $p$ en fonction de $n$ et typiquement
            $p(n) = o(1)$. \`A noter que dans cette méthode, on ne peut
            connaître à l'avance le nombre d'arrêtes du graphe généré.
            Gr\^ace à l'analyse de ce type fournie par \cite{newman2001random},
            on sait que la probabilité $p_k$ qu'un n\oe{}ud pris au hasard
            soit de degré $k$ vaut :
            \[
                p_k = \binom{|V|}{k} p^k (1 - p)^{N - k}.
            \]
            En notant $z = \mathbb{E}\left[|E|\right] = |V|p$, on a le résultat
            suivant :
            \[
                p_k \underset{N \rightarrow +\infty}{\sim}
                \frac{z^k e^{-z}}{k!},
            \]
            ce qui indique que ce modèle tend asymptotiquement vers une
            distribution des degrés suivant une loi de Poisson.

        \subsubsection{Modèle d'Erdös-Rényi}

\section{Méthodes MCMC}
\label{sec:methodes_mcmc}
    Soit $G = (V, E)$ un graphe non orienté.
    Les méthodes MCMC pour la génération de graphes sont très vastement
    utilisées (\cite{rao1996markov}). Leur principe général est de partir
    d'un graphe existant et de modifier aléatoirement ses arrêtes, tout en
    conservant certaines propriétés du graphe. L'Algorithme~\ref{alg:mcmc_deg}
    sélectionne aléatoirement deux arrêtes, puis les échange si cela
    n'entraine ni la création de boucle ni de double arrête.

    \begin{algorithm}
        \caption{Algorithme MCMC conservant les degrés des n\oe{}uds.}
        \label{alg:mcmc_deg}
        \begin{algorithmic}[1]
            \Require $V, E, N_{max}$
            \State $E^{(0)} \gets E$
            \State $i \gets 1$
            \While{$i \leq N_{max}$}
                \State $(e_1, e_2) \gets \text{rand}(E^{(i-1)})$
                \State $(f_1, f_2) \gets \text{rand}(E^{(i-1)})$
                \If{no loop and no double edge created}
                    \State $E^{(i)} \gets$
                        \textbf{swap}($E^{(i-1)}$, $(e_1, e_2)$, $(f_1, f_2)$)
                \Else
                    \State $E^{(i)} \gets E^{(i-1)}$
                \EndIf
                \State $i \gets i + 1$
            \EndWhile
        \end{algorithmic}
    \end{algorithm}

    Cet algorithme est simple à implémenter et ne nécessite qu'un paramètre :
    le nombre d'itérations $N_{max}$. En général, on choisit $N_{max}$ de
    l'ordre de $100 \times |E|$ pour s'assurer un graphe généré indépendant de
    l'original. Cependant, ce choix est purement expérimental et il existe peu
    de travaux théoriques sur ces critères ; \cite{ray2012we} présente
    toutefois des résultats intéressants sur des critères d'arrêts spécifiques.

    \begin{algorithm}
        \caption{Algorithme MCMC pour la génération de graphe.}
        \label{alg:mcmc_joint}
        \begin{algorithmic}
            \Require $V, E, N_{max}$
            \State $E^{(0)} \gets E$
            \State $i \gets 1$
            \While{$i \leq N_{max}$}
                \State $(e_1, e_2) \gets \text{rand}(E^{(i-1)})$
                \State $(f_1, f_2) \gets \text{rand}(\left\{ (u, v) \in E^{(i-1)}, d_u = d_{e_1} \right\})$
                \State $E^{(i)} \gets$
                    \textbf{swap}($E^{(i-1)}$, $(e_1, e_2)$, $(f_1, f_2)$)
                \State $i \gets i + 1$
            \EndWhile \\
            \Return $(V, E^{(N_{max})})$
        \end{algorithmic}
    \end{algorithm}

    \bibliographystyle{alpha}
    \bibliography{network}

\end{document}


